# parceljs

## RegExp（正则表达式）

```
正则表达式就是记录文本规则的代码
```
[参考地址](https://deerchao.net/tutorials/regex/regex.htm)

### 元字符

```
就是用来构成正则表达式的最小字符，通过这些字符去匹配不同的内容；
是拥有特殊含义的字符
```
| 代码 | 说明 |
| --- | --- |
| . | 匹配除换行符以外的任意字符 |
| \w | 匹配字母、数字、下划线、汉字 |
| \s | 匹配任意的空白符 |
| \d | 匹配数字 |
| \b | 匹配单词的开始或者结束 |
| ^ | 匹配字符串的开始 |
| $ | 匹配字符串的结束 |

### 字符转义

```
如果要查找/匹配元字符本身的话，就得先对这个字符进行转义
用 \ 进行转义；比如：\. \* \( \) \\
```

### 重复

```
也属于正则的元字符；他的作用就是指定匹配结果的数量
```
| 代码/语法 | 说明 |
| --- | --- |
| * | 重复零次或者更多次 |
| + | 重复一次或者更多次 |
| ？ | 重复零次或者一次 |
| {n} | 重复n次 |
| {n,} | 重复n次或者更多次 |
| {n,m} | 重复n到m次 |

```
在写{}的时候，一定不要在,号后面加上空格
正确写法 \d{1,3}; 错误写法\d{1, 3};
因为很多同学有良好的代码风格之后，就习惯在,号后面加上空格
```


### 字符类

```
用 [] 把相关的内容括起来
用于查找某个范围内的字符
```

### 分支条件

```
用 |  把不同的规则隔开;
| 左右两边就是一个单独的正则表达式
```

### 分组

```
用 () 进行分组
```

### 反义

```
其实也就是一些无字符，就是匹配的内容是从反面去取的
```
| 代码/语法 | 说明 |
| --- | --- |
| \W | 匹配任意不是字母、数字、下划线、汉字的字符 |
| \S | 匹配任意不是空白符的字符 |
| \D | 匹配任意不是数字的字符 |
| \B | 匹配任意不是单词开头或者结束的位置 |
| [\^x] | 匹配除了x以外的任意字符 |
| [\^aeiou] | 匹配除了aeiou这几个字母以外的任意字符 |

### 后向引用
```
使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是些分组捕获的内容)可以在表达式或其它程序中做进一步的处理。
默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。
后向引用于重复搜索前面某个分组匹配的的文本。
```
#### 使用小括号的特定语法

| 分类 | 代码/语法 | 说明 |
| :-: | :-: | :-: |
| **捕获** | (exp) | 匹配exp,并捕获文本到自动命名的组里 |
|  | (?<name>exp) | 匹配exp,并捕获文本到名称为name的组里,也可以写成(?’name'exp) |
|  | (?:exp) | 匹exp,不捕获匹配的文本，也不给此分组创分配到组号 |
| **零宽断言** | (?=exp) | 匹配exp前面的位置 |
|  | (?<=exp) | 匹配exp后面的位置 |
|  | (?!exp) | 匹配后面跟的不是exp的位置 |
|  | (?<!exp) | 匹配前面不是exp的位置 |

### 零宽断言

```
查找在某些内容(但不包括这些内容)之前或者之后的东西，也就是说像 \b, ^, $ 那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为 零宽断言。
(?=exp): 零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。
(?<=exp): 零宽度正回顾扣发断言，它断言自身出现的位置的前面能匹配表达式exp。
```

> 断言用来声明一个应该为真的事实。
> 正则表达式中只有当断言为真时才会继续进行。

### 贪婪与懒惰

```
当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。
以这个表达式为例：
a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。

有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。
现在看看懒惰版的例子吧：
a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。

>为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权
```

| 代码/语法 | 说明 |
| --- | --- |
| *? | 重复任意次，但尽可能的少重复 |
| +? | 重复1次或者更多次，但尽可能少的重复 |
| ?? | 重复0次或者1次，但尽可能少的重复 |
| {n,m}? | 重复n到m次，但尽可能少的重复 |
| {n,}? | 重复n次以上，但尽可能少的重复 |



